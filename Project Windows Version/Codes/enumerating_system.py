import os
import json
from fpdf import FPDF
import paramiko
from prettytable import PrettyTable
import getpass

def create_ssh_connection(host, port, username, password):
    """Create and return an SSH connection using provided credentials."""
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(host, port=port, username=username, password=password)
    return ssh

def detect_os(ssh):
    """Detect the operating system of the connected machine."""
    try:
        stdin, stdout, stderr = ssh.exec_command('uname -a')
        if stdout.read().decode().strip():
            return 'unix'
    except Exception:
        pass
    try:
        stdin, stdout, stderr = ssh.exec_command('ver')
        if stdout.read().decode().strip():
            return 'windows'
    except Exception:
        pass
    return None

def fetch_data(ssh, os_type):
    """Fetch system data based on the detected operating system."""
    data = {
        'users': [],
        'software': [],
        'network_info': [],
        'system_resources': [],
        'disk_usage': [],
        'scheduled_tasks': []
    }

    if os_type == 'unix':
        data['users'] = fetch_users_unix(ssh)
        data['software'] = fetch_software_unix(ssh)
        data['network_info'] = fetch_network_info_unix(ssh)
        data['system_resources'] = fetch_system_resources_unix(ssh)
        data['disk_usage'] = fetch_disk_usage_unix(ssh)
        data['scheduled_tasks'] = fetch_scheduled_tasks_unix(ssh)
    elif os_type == 'windows':
        data['users'] = fetch_users_windows(ssh)
        data['software'] = fetch_software_windows(ssh)
        data['network_info'] = fetch_network_info_windows(ssh)
        data['system_resources'] = ["Windows resource fetching not implemented."]
        data['disk_usage'] = fetch_disk_usage_windows(ssh)
        data['scheduled_tasks'] = fetch_scheduled_tasks_windows(ssh)
    return data

def display_tables(data):
    """Display fetched data in tabular format."""
    for key, values in data.items():
        print(f"\n{key.upper()}:\n")
        table = PrettyTable()
        table.field_names = [key]
        for value in values:
            table.add_row([value])
        print(table)

def save_report(data, file_format, file_name, directory_path):
    """Generate a report from fetched data and save it to a specific location in the chosen format."""
    os.makedirs(directory_path, exist_ok=True)
    file_path = os.path.join(directory_path, file_name + '.' + file_format)
    
    if file_format == 'pdf':
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font("Arial", size=12)
        
        for key, values in data.items():
            pdf.set_font("Arial", 'B', 16)
            pdf.cell(200, 10, txt=f"{key.upper()}:", ln=1)
            pdf.set_font("Arial", size=12)
            for value in values:
                wrapped_text = pdf.multi_cell(0, 10, txt=value, align='L')
        pdf.output(file_path)

def user_input_and_save_report(system_data):
    """Ask user for file format, file name, and directory path, then generate and save the report."""
    file_format = input("Enter the file format (txt, json, pdf): ").lower()
    if file_format not in ['txt', 'json', 'pdf']:
        print("Invalid format selected. Defaulting to txt.")
        file_format = 'txt'
    file_name = input("Enter the filename without extension: ")
    directory_path = input("Enter the directory path where you want to save the file: ")

# Ensure the directory path is not empty
    while not directory_path:
        print("Directory path cannot be empty.")
        directory_path = input("Please enter a valid directory path where you want to save the file: ")

    # Try creating the directory if it doesn't exist
    try:
        os.makedirs(directory_path, exist_ok=True)
    except OSError as error:
        print(f"Error creating directory: {error}")
        return  # Exit the function if the directory cannot be created

    save_report(system_data, file_format, file_name, directory_path)

def enumerate_system(host, port, username, password):
    """Main function to handle system enumeration process with report generation."""
    ssh = create_ssh_connection(host, port, username, password)
    try:
        os_type = detect_os(ssh)
        if not os_type:
            print("Failed to detect OS type.")
            return
        system_data = fetch_data(ssh, os_type)
        if system_data:
            display_tables(system_data)
            user_input_and_save_report(system_data)
        else:
            print("No data fetched.")
    finally:
        ssh.close()

# Unix-specific fetching functions
def fetch_users_unix(ssh):
    stdin, stdout, stderr = ssh.exec_command('cat /etc/passwd')
    return [line.split(':')[0] for line in stdout.read().decode().split('\n') if line]

def fetch_software_unix(ssh):
    stdin, stdout, stderr = ssh.exec_command('dpkg --list')
    return [line.strip().split()[1] for line in stdout.read().decode().split('\n') if line.startswith('ii')]

def fetch_network_info_unix(ssh):
    stdin, stdout, stderr = ssh.exec_command('ifconfig')
    return stdout.read().decode().split('\n\n')

def fetch_system_resources_unix(ssh):
    cmd = "top -b -n1 | head -5"
    stdin, stdout, stderr = ssh.exec_command(cmd)
    return stdout.read().decode().split('\n')[:3]

def fetch_disk_usage_unix(ssh):
    cmd = "df -h"
    stdin, stdout, stderr = ssh.exec_command(cmd)
    return stdout.read().decode().split('\n')[1:]

def fetch_scheduled_tasks_unix(ssh):
    cmd = "crontab -l"
    stdin, stdout, stderr = ssh.exec_command(cmd)
    return stdout.read().decode().split('\n') if stdout.read().decode() else ["No scheduled tasks found"]

# Windows-specific fetching functions
def fetch_users_windows(ssh):
    stdin, stdout, stderr = ssh.exec_command('net user')
    output = stdout.read().decode()
    return [line.strip() for line in output.split('\n') if line.strip() and "----" not in line and "User accounts" not in line]

def fetch_software_windows(ssh):
    cmd = "powershell \"Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Select-Object DisplayName, DisplayVersion\""
    stdin, stdout, stderr = ssh.exec_command(cmd)
    return [line.strip() for line in stdout.read().decode().split('\n') if line]

def fetch_network_info_windows(ssh):
    stdin, stdout, stderr = ssh.exec_command('ipconfig')
    return stdout.read().decode().split('\r\n\r\n')

def fetch_disk_usage_windows(ssh):
    cmd = "powershell \"Get-PSDrive -PSProvider 'FileSystem'\""
    stdin, stdout, stderr = ssh.exec_command(cmd)
    return stdout.read().decode().split('\n')[3:-2]

def fetch_scheduled_tasks_windows(ssh):
    cmd = "schtasks"
    stdin, stdout, stderr = ssh.exec_command(cmd)
    return stdout.read().decode().split('\n')[1:]
