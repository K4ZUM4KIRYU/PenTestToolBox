import requests
from urllib.parse import urljoin
import threading
import json
import os
from fpdf import FPDF
import re

# Shared flag to control the execution and event to signal completion
stop_requested = False
scan_complete = threading.Event()

def format_url(input_value):
    """Ensure the URL has http:// or https:// prefix."""
    if not input_value.startswith(('http://', 'https://')):
        return f"http://{input_value}"
    return input_value

def fetch_directory_content(url):
    """Attempt to fetch content from the specified URL quietly, handling errors without output."""
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()  # Raises an HTTPError for bad responses
        return response.text
    except requests.exceptions.RequestException:
        return None
    
def extract_information(content):
    """Extract emails, URLs, potential passwords, and other sensitive data from content."""
    email_pattern = re.compile(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b')
    url_pattern = re.compile(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+')
    password_pattern = re.compile(r'(?i)(password|pass|pwd)[\'"]?\s*[:=]\s*[\'"]?(\w+)')
    sensitive_data_pattern = re.compile(r'(?i)(apikey|api_key|token|secret|authorization)[\'"]?\s*[:=]\s*[\'"]?(\w+)')

    emails = email_pattern.findall(content)
    urls = url_pattern.findall(content)
    passwords = password_pattern.findall(content)
    sensitive_data = sensitive_data_pattern.findall(content)

    return {
        'emails': emails,
        'urls': urls,
        'passwords': passwords,
        'sensitive_data': sensitive_data
    }
    
def get_directory_list():
    """Prompt user to input directory list directly or via file."""
    choice = input("Enter '1' to input directory list or '2' to specify a path to a file with directory names: ")
    directory_list = []
    if choice == '1':
        directories = input("Enter directories separated by commas (e.g., admin,config,login): ")
        directory_list = [dir.strip() for dir in directories.split(',')]
    elif choice == '2':
        filepath = input("Enter the full path to the file containing directory names: ")
        try:
            with open(filepath, 'r') as file:
                directory_list = [line.strip() for line in file if line.strip()]
        except FileNotFoundError:
            print(f"Error: File not found at {filepath}")
        except Exception as e:
            print(f"An error occurred: {e}")
    return directory_list

def brute_force_directories(url, directory_list):
    """Brute force directories on a web server and fetch content along with sensitive data."""
    found_directories = []
    for dir_name in directory_list:
        if stop_requested:
            break
        full_url = urljoin(url, dir_name)
        content = fetch_directory_content(full_url)
        if content:
            extracted_info = extract_information(content)
            extracted_info['URL'] = full_url
            extracted_info['Content'] = content[:200]  # Store a content snippet for preview
            found_directories.append(extracted_info)
            print(f"Found directory: {full_url} with data: {extracted_info}")
        else:
            print(f"Testing {full_url}... not found or no access.")
    scan_complete.set()
    return found_directories

def monitor_stop_command():
    """Monitor for a stop command from the user and check for scan completion."""
    global stop_requested
    while not scan_complete.is_set():
        input_text = input("\nType 'stop' to end the scan and save data or wait for completion: ")
        if input_text.lower() == 'stop':
            stop_requested = True
            print("Stop requested...finishing up.")
            break

def save_report(data, file_format, file_name, directory_path):
    """Save the report data in the specified format."""
    os.makedirs(directory_path, exist_ok=True)
    file_path = os.path.join(directory_path, f"{file_name}.{file_format}")
    
    if file_format == 'json':
        with open(file_path, 'w', encoding='utf-8') as file:
            json.dump(data, file, indent=4)
    elif file_format == 'txt':
        with open(file_path, 'w', encoding='utf-8') as file:
            for entry in data:
                file.write(f"URL: {entry['URL']}\nEmails: {entry['emails']}\nURLs: {entry['urls']}\nPasswords: {entry['passwords']}\nSensitive Data: {entry['sensitive_data']}\nContent: {entry['Content']}\n\n")
    elif file_format == 'pdf':
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font("Arial", size=12)
        
        # Define column width relative to the page width
        column_width = pdf.w - 2 * pdf.l_margin
        
        # Adding headers and handling content
        for entry in data:
            pdf.set_font("Arial", 'B', 14)
            pdf.cell(column_width, 10, 'Directory Report', 0, 1, 'C')
            pdf.set_font("Arial", size=12)
            pdf.cell(column_width, 10, 'URL: ' + entry['URL'], 0, 1)
            
            pdf.set_font("Arial", 'B', 12)
            pdf.cell(column_width, 10, 'Emails Found:', 0, 1)
            pdf.set_font("Arial", size=12)
            pdf.multi_cell(column_width, 10, ', '.join(entry['emails']))
            
            pdf.set_font("Arial", 'B', 12)
            pdf.cell(column_width, 10, 'URLs Found:', 0, 1)
            pdf.set_font("Arial", size=12)
            pdf.multi_cell(column_width, 10, ', '.join(entry['urls']))
            
            pdf.set_font("Arial", 'B', 12)
            pdf.cell(column_width, 10, 'Passwords Found:', 0, 1)
            pdf.set_font("Arial", size=12)
            pdf.multi_cell(column_width, 10, ', '.join([p[1] for p in entry['passwords']]))
            
            pdf.set_font("Arial", 'B', 12)
            pdf.cell(column_width, 10, 'Sensitive Data Found:', 0, 1)
            pdf.set_font("Arial", size=12)
            pdf.multi_cell(column_width, 10, ', '.join([s[1] for s in entry['sensitive_data']]))
            
            pdf.set_font("Arial", 'B', 12)
            pdf.cell(column_width, 10, 'Content Preview:', 0, 1)
            pdf.set_font("Arial", size=12)
            pdf.multi_cell(column_width, 10, entry['Content'][:200] + '...')
            
            pdf.cell(column_width, 10, '', 0, 1)  # Adding extra space between entries

        pdf.output(file_path)

def run_web_enum():
    """Main function to run web directory brute-forcing."""
    global stop_requested
    stop_requested = False
    scan_complete.clear()

    user_input = input("Enter the target IP address or URL: ")
    formatted_url = format_url(user_input)
    print("Please provide directories to test. You can enter them manually separated by commas,")
    print("or specify a path to a text file that contains one directory per line.")
    directory_list = input("Enter directories or file path: ").strip()

    if os.path.isfile(directory_list):
        with open(directory_list, 'r') as file:
            directory_list = [line.strip() for line in file if line.strip()]
    else:
        directory_list = [x.strip() for x in directory_list.split(',') if x.strip()]

    if not directory_list:
        print("No directories provided. Exiting...")
        return

    thread = threading.Thread(target=monitor_stop_command)
    thread.daemon = True
    thread.start()

    found_directories = brute_force_directories(formatted_url, directory_list)
    scan_complete.set()  # Ensure to set the event if scanning finishes before any input
    thread.join()  # Ensure the stop command thread has finished

    print("Brute force complete. Directories found:")
    for directory in found_directories:
        print(f"{directory['URL']} - Emails: {directory['emails']} URLs: {directory['urls']}, Passwords: {directory['passwords']}, Sensitive Data: {directory['sensitive_data']}")

    file_format = input("Enter the file format (txt, json, pdf): ").lower()
    file_name = input("Enter the filename without extension: ")
    directory_path = input("Enter the directory path where you want to save the file: ")

    # Ensure the directory path is not empty
    while not directory_path:
        print("Directory path cannot be empty.")
        directory_path = input("Please enter a valid directory path where you want to save the file: ")

    # Try creating the directory if it doesn't exist
    try:
        os.makedirs(directory_path, exist_ok=True)
    except OSError as error:
        print(f"Error creating directory: {error}")
        return  # Exit the function if the directory cannot be created

    save_report(found_directories, file_format, file_name, directory_path)


